use std::borrow::Cow;
use std::collections::HashMap;
use std::io::{Read, Write};
use std::path::{Path, PathBuf};

use color_eyre::eyre::{Result, WrapErr};
use itertools::Itertools;
use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use tokio::fs;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

use crate::types::version::VersionNumber;

lazy_static! {
    static ref DEFAULT_JVM_ARGS: Vec<String> = vec!["-Xms4G".to_string(), "-Xmx4G".to_string()];
    static ref DEFAULT_SERVER_ARGS: Vec<String> = vec!["--nogui".to_string()];
}

trait AsArgs {
    fn as_args(&self) -> Vec<String>;

    fn as_args_string(&self) -> String {
        // preserve quotes
        self.as_args()
            .iter()
            .map(|s| shell_escape::escape(Cow::Borrowed(s)))
            .join(" ")
    }
}

impl<T> AsArgs for T
where T: Clone + Into<Vec<String>>
{
    fn as_args(&self) -> Vec<String> {
        self.clone().into()
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct InstanceJavaSettings {
    /// The major version of the JVM to use
    ///
    /// Will be either 8, 16, or 17 by default,
    /// depending on the server version
    pub version: u8,
    /// The arguments to pass to the JVM
    pub args: Vec<String>,
}

impl InstanceJavaSettings {
    pub fn new(version: u8) -> Self {
        Self {
            version,
            args: DEFAULT_JVM_ARGS.as_args(),
        }
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct InstanceServerSettings {
    /// The path to the server jar file, relative to the instance directory
    pub jar: PathBuf,
    /// The arguments to pass to the server
    pub args: Vec<String>,
}

impl Default for InstanceServerSettings {
    fn default() -> Self {
        Self {
            jar: PathBuf::from("server.jar"),
            args: DEFAULT_SERVER_ARGS.as_args(),
        }
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct InstanceSettings {
    /// The settings for the JVM
    pub java: InstanceJavaSettings,
    /// The settings relating to the server
    pub server: InstanceServerSettings,
}

impl InstanceSettings {
    pub fn new(version: u8) -> Self {
        Self {
            java: InstanceJavaSettings::new(version),
            server: InstanceServerSettings::default(),
        }
    }

    pub async fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let path = path.as_ref();
        let mut file = fs::File::open(path)
            .await
            .wrap_err(format!("Error reading settings at {}", path.display()))?;

        let mut contents = String::new();
        file.read_to_string(&mut contents)
            .await
            .wrap_err(format!("Error reading settings at {}", path.display()))?;

        let settings: InstanceSettings = toml::from_str(&contents)
            .wrap_err(format!("Error parsing settings at {}", path.display()))?;

        Ok(settings)
    }

    pub async fn save<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        let path = path.as_ref();
        fs::create_dir_all(path.parent().expect("infallible")).await?;
        let mut file = fs::File::create(path).await.wrap_err(format!(
            "Error creating settings file at {}",
            path.display()
        ))?;

        let mut contents =
            "# This file is automatically generated\n# Only edit if you know what you're doing!\n\n"
                .to_string();
        contents.push_str(&toml::to_string(self)?);

        file.write_all(contents.as_bytes()).await.wrap_err(format!(
            "Error writing settings to file at {}",
            path.display()
        ))?;

        Ok(())
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct InstanceMeta {
    pub id: VersionNumber,
    pub files: Vec<PathBuf>,
    pub jre: u8, // String?
}

impl InstanceMeta {
    pub fn new(id: VersionNumber, jre: u8) -> Self {
        Self {
            id,
            files: Vec::new(),
            jre,
        }
    }

    pub fn add_file(&mut self, file: &PathBuf) {
        self.files.push(file.clone());
    }

    pub fn remove_file(&mut self, file: &PathBuf) {
        self.files.retain(|f| f != file);
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct AppMeta {
    // keyed by id for now, possibly changed later to allow for multiple instances with the same version
    pub instances: HashMap<String, InstanceMeta>,
    pub installed_jres: Vec<u8>, // String?
}

impl Default for AppMeta {
    fn default() -> Self {
        Self {
            instances: HashMap::new(),
            installed_jres: Vec::new(),
        }
    }
}

impl AppMeta {
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let path = path.as_ref();
        let mut file = std::fs::File::open(path)
            .wrap_err(format!("Error reading meta at {}", path.display()))?;

        let mut contents = String::new();
        file.read_to_string(&mut contents)
            .wrap_err(format!("Error reading meta at {}", path.display()))?;

        let meta: AppMeta = toml::from_str(&contents)?;

        Ok(meta)
    }

    pub fn save<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        let path = path.as_ref();
        std::fs::create_dir_all(path.parent().expect("infallible"))?;
        let mut file = std::fs::File::create(path)
            .wrap_err(format!("Error creating meta file at {}", path.display()))?;

        let mut contents = String::new();
        contents.push_str(&toml::to_string(self)?);

        file.write_all(contents.as_bytes())
            .wrap_err(format!("Error writing meta to file at {}", path.display()))?;

        Ok(())
    }

    pub fn read_or_create<P: AsRef<Path>>(path: P) -> Self {
        let path = path.as_ref();
        if let Ok(meta) = Self::from_file(path) {
            meta
        } else {
            let meta = Self::default();
            meta.save(path).expect("Error saving meta"); // TODO: handle error
            meta
        }
    }

    pub fn add_instance(&mut self, instance: InstanceMeta) {
        self.instances.insert(instance.id.to_string(), instance);
    }

    pub fn add_jre(&mut self, jre: u8) {
        if !self.installed_jres.contains(&jre) {
            self.installed_jres.push(jre);
        }
    }
}

#[cfg(test)]
mod tests {
    use rand::distributions::{Alphanumeric, DistString};

    use super::*;

    #[tokio::test]
    async fn read_write_settings() {
        let suf: String = Alphanumeric.sample_string(&mut rand::thread_rng(), 5);
        let path = PathBuf::from(format!("settings-{suf}.toml"));

        scopeguard::defer! {
            std::fs::remove_file(&path).unwrap();
        }

        let settings = InstanceSettings::new(8);
        settings.save(&path).await.unwrap();
        let settings = InstanceSettings::from_file(&path).await.unwrap();
        assert_eq!(settings.java.version, 8);
        assert_eq!(
            settings.java.args,
            DEFAULT_JVM_ARGS
                .iter()
                .map(|s| s.to_string())
                .collect::<Vec<String>>()
        );
        assert_eq!(settings.server.jar, PathBuf::from("server.jar"));
        assert_eq!(settings.server.args, vec!["--nogui".to_string()]);
    }

    #[tokio::test]
    #[should_panic = "Error reading settings at settings-"]
    async fn read_settings_nonexistent() {
        let suf: String = Alphanumeric.sample_string(&mut rand::thread_rng(), 5);
        let path = PathBuf::from(format!("settings-{suf}.toml"));

        let _settings = InstanceSettings::from_file(&path).await.unwrap();
    }

    #[tokio::test]
    #[should_panic = "TOML parse error"]
    async fn read_settings_invalid() {
        let suf: String = Alphanumeric.sample_string(&mut rand::thread_rng(), 5);
        let path = PathBuf::from(format!("settings-{suf}.toml"));

        scopeguard::defer! {
            std::fs::remove_file(&path).unwrap();
        }

        fs::write(&path, "invalid").await.unwrap();
        let _settings = InstanceSettings::from_file(&path).await.unwrap();
    }
}
