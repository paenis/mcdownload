use std::borrow::Cow;
use std::path::{Path, PathBuf};
use std::str::FromStr;

use color_eyre::eyre::{Result, WrapErr};
use itertools::Itertools;
use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use tokio::fs;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

lazy_static! {
    static ref DEFAULT_JVM_ARGS: Vec<String> = vec!["-Xms4G".to_string(), "-Xmx4G".to_string()];
    static ref DEFAULT_SERVER_ARGS: Vec<String> = vec!["--nogui".to_string()];
}

trait AsArgs {
    fn as_args(&self) -> Vec<String>;

    fn as_args_string(&self) -> String {
        // preserve quotes
        self.as_args()
            .iter()
            .map(|s| shell_escape::escape(Cow::Borrowed(s)))
            .join(" ")
    }
}

impl<T> AsArgs for T
where T: Clone + Into<Vec<String>>
{
    fn as_args(&self) -> Vec<String> {
        self.clone().into()
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct InstanceJavaSettings {
    /// The major version of the JVM to use
    ///
    /// Will be either 8, 16, or 17 by default,
    /// depending on the server version
    pub version: u8,
    /// The arguments to pass to the JVM
    pub args: Vec<String>,
}

impl InstanceJavaSettings {
    pub fn new(version: u8) -> Self {
        Self {
            version,
            args: DEFAULT_JVM_ARGS.as_args(),
        }
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct InstanceServerSettings {
    /// The path to the server jar file, relative to the instance directory
    pub jar: PathBuf,
    /// The arguments to pass to the server
    pub args: Vec<String>,
}

impl Default for InstanceServerSettings {
    fn default() -> Self {
        Self {
            jar: PathBuf::from("server.jar"),
            args: DEFAULT_SERVER_ARGS.as_args(),
        }
    }
}

#[derive(Serialize, Deserialize)]
pub(crate) struct InstanceSettings {
    /// The settings for the JVM
    pub java: InstanceJavaSettings,
    /// The settings relating to the server
    pub server: InstanceServerSettings,
}

impl InstanceSettings {
    pub fn new(version: u8) -> Self {
        Self {
            java: InstanceJavaSettings::new(version),
            server: InstanceServerSettings::default(),
        }
    }

    pub async fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let path = path.as_ref();
        let mut file = fs::File::open(path)
            .await
            .wrap_err(format!("Error reading settings at {}", path.display()))?;

        let mut contents = String::new();
        file.read_to_string(&mut contents)
            .await
            .wrap_err(format!("Error reading settings at {}", path.display()))?;

        let settings: InstanceSettings = toml::from_str(&contents)?;

        Ok(settings)
    }

    pub async fn save<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        let path = path.as_ref();
        fs::create_dir_all(path.parent().expect("infallible")).await?;
        let mut file = fs::File::create(path).await.wrap_err(format!(
            "Error creating settings file at {}",
            path.display()
        ))?;

        let mut contents =
            "# This file is automatically generated\n# Only edit if you know what you're doing!\n\n"
                .to_string();
        contents.push_str(&toml::to_string(self)?);

        file.write_all(contents.as_bytes()).await.wrap_err(format!(
            "Error writing settings to file at {}",
            path.display()
        ))?;

        Ok(())
    }
}

enum ServerType {
    Vanilla,
    Paper,
    Fabric,
    Forge,
}

impl FromStr for ServerType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "vanilla" => Ok(ServerType::Vanilla),
            "paper" => Ok(ServerType::Paper),
            "fabric" => Ok(ServerType::Fabric),
            "forge" => Ok(ServerType::Forge),
            _ => Err(format!("Invalid server type: {}", s)),
        }
    }
}

#[cfg(test)]
mod tests {
    use rand::distributions::{Alphanumeric, DistString};

    use super::*;

    #[tokio::test]
    async fn read_write_settings() {
        let suf: String = Alphanumeric.sample_string(&mut rand::thread_rng(), 5);
        let path = PathBuf::from(format!("settings-{suf}.toml"));

        scopeguard::defer! {
            std::fs::remove_file(&path).unwrap();
        }

        let settings = InstanceSettings::new(8);
        settings.save(&path).await.unwrap();
        let settings = InstanceSettings::from_file(&path).await.unwrap();
        assert_eq!(settings.java.version, 8);
        assert_eq!(
            settings.java.args,
            DEFAULT_JVM_ARGS
                .iter()
                .map(|s| s.to_string())
                .collect::<Vec<String>>()
        );
        assert_eq!(settings.server.jar, PathBuf::from("server.jar"));
        assert_eq!(settings.server.args, vec!["--nogui".to_string()]);
    }

    #[tokio::test]
    #[should_panic = "Error reading settings at settings-"]
    async fn read_settings_nonexistent() {
        let suf: String = Alphanumeric.sample_string(&mut rand::thread_rng(), 5);
        let path = PathBuf::from(format!("settings-{suf}.toml"));

        let _settings = InstanceSettings::from_file(&path).await.unwrap();
    }

    #[tokio::test]
    #[should_panic = "TOML parse error"]
    async fn read_settings_invalid() {
        let suf: String = Alphanumeric.sample_string(&mut rand::thread_rng(), 5);
        let path = PathBuf::from(format!("settings-{suf}.toml"));

        scopeguard::defer! {
            std::fs::remove_file(&path).unwrap();
        }

        fs::write(&path, "invalid").await.unwrap();
        let _settings = InstanceSettings::from_file(&path).await.unwrap();
    }
}
